# Imle Wrapper

[_Documentation generated by Documatic_](https://www.documatic.com)

<!---Documatic-section-Codebase Structure-start--->
## Codebase Structure

<!---Documatic-block-system_architecture-start--->
```mermaid
None
```
<!---Documatic-block-system_architecture-end--->

# #
<!---Documatic-section-Codebase Structure-end--->

<!---Documatic-section-imle.wrapper.imle-start--->
## [imle.wrapper.imle](3-imle_wrapper.md#imle.wrapper.imle)

<!---Documatic-section-imle-start--->
<!---Documatic-block-imle.wrapper.imle-start--->
<details>
	<summary><code>imle.wrapper.imle</code> code snippet</summary>

```python
def imle(function: Callable[[Tensor], Tensor]=None, target_distribution: Optional[BaseTargetDistribution]=None, noise_distribution: Optional[BaseNoiseDistribution]=None, nb_samples: int=1, input_noise_temperature: float=1.0, target_noise_temperature: float=1.0):
    if target_distribution is None:
        target_distribution = TargetDistribution(alpha=1.0, beta=1.0)
    if function is None:
        return functools.partial(imle, target_distribution=target_distribution, noise_distribution=noise_distribution, nb_samples=nb_samples, input_noise_temperature=input_noise_temperature, target_noise_temperature=target_noise_temperature)

    @functools.wraps(function)
    def wrapper(input: Tensor, *args):

        class WrappedFunc(torch.autograd.Function):

            @staticmethod
            def forward(ctx, input: Tensor, *args):
                input_shape = input.shape
                batch_size = input_shape[0]
                instance_shape = input_shape[1:]
                perturbed_input_shape = [batch_size, nb_samples] + list(instance_shape)
                if noise_distribution is None:
                    noise = torch.zeros(size=perturbed_input_shape)
                else:
                    noise = noise_distribution.sample(shape=torch.Size(perturbed_input_shape))
                input_noise = noise * input_noise_temperature
                perturbed_input_3d = input.view(batch_size, 1, -1).repeat(1, nb_samples, 1).view(perturbed_input_shape)
                perturbed_input_3d = perturbed_input_3d + input_noise
                perturbed_input_2d = perturbed_input_3d.view([-1] + perturbed_input_shape[2:])
                perturbed_input_2d_shape = perturbed_input_2d.shape
                perturbed_output = function(perturbed_input_2d)
                perturbed_output = perturbed_output.view(perturbed_input_shape)
                ctx.save_for_backward(input, noise, perturbed_output)
                res = perturbed_output.view(perturbed_input_2d_shape)
                return res

            @staticmethod
            def backward(ctx, dy):
                (input, noise, perturbed_output_3d) = ctx.saved_variables
                input_shape = input.shape
                batch_size = input_shape[0]
                dy_shape = dy.shape
                noise_shape = noise.shape
                input_2d = input.view(batch_size, 1, -1).repeat(1, nb_samples, 1).view(dy_shape)
                target_input_2d = target_distribution.params(input_2d, dy)
                target_input_3d = target_input_2d.view(noise_shape)
                target_noise = noise * target_noise_temperature
                perturbed_target_input_3d = target_input_3d + target_noise
                perturbed_target_input_2d = perturbed_target_input_3d.view(dy_shape)
                target_output_2d = function(perturbed_target_input_2d)
                target_output_3d = target_output_2d.view(noise_shape)
                gradient = perturbed_output_3d - target_output_3d
                gradient = gradient.mean(axis=1)
                return gradient
        return WrappedFunc.apply(input, *args)
    return wrapper
```
</details>
<!---Documatic-block-imle.wrapper.imle-end--->
<!---Documatic-section-imle-end--->

# #
<!---Documatic-section-imle.wrapper.imle-end--->

[_Documentation generated by Documatic_](https://www.documatic.com)